[{"tags":[],"description":{"full":"<p>Lunr - 0.1.0<br />Copyright (C) 2011 Oliver Nightingale<br />MIT Licensed</p>","summary":"<p>Lunr - 0.1.0<br />Copyright (C) 2011 Oliver Nightingale<br />MIT Licensed</p>","body":""},"ignore":true,"code":";"},{"tags":[{"type":"param","types":["Function"],"name":"config","description":"- A function that will be run with a newly created Lunr.Index as its context."},{"type":"returns"}],"description":{"full":"<p>Convinience method for instantiating and configuring a new Lunr index</p>","summary":"<p>Convinience method for instantiating and configuring a new Lunr index</p>","body":""},"isPrivate":false,"ignore":false,"code":"var Lunr = function (name, config) {\n  var index = new Lunr.Index (name)\n  config.call(index, index)\n  return index\n};","ctx":{"type":"function","name":"Lunr","string":"Lunr()"}},{"tags":[],"description":{"full":"<p>Lunr - utils<br />Copyright (C) 2011 Oliver Nightingale<br />MIT Licensed</p>","summary":"<p>Lunr - utils<br />Copyright (C) 2011 Oliver Nightingale<br />MIT Licensed</p>","body":""},"ignore":true},{"tags":[],"description":{"full":"<p>A collection of utils that are used as part of the Lunr code base.</p>","summary":"<p>A collection of utils that are used as part of the Lunr code base.</p>","body":""},"ignore":false,"code":"Lunr.utils = {","ctx":{"type":"property","receiver":"Lunr","name":"utils","value":"{","string":"Lunr.utils"}},{"tags":[{"type":"private"},{"type":"params"},{"type":"returns"}],"description":{"full":"<h2>Lunr.utils.uniq</h2>\n\n<p>Retuns an array with duplicate elements removed.</p>","summary":"<h2>Lunr.utils.uniq</h2>\n\n<p>Retuns an array with duplicate elements removed.</p>","body":""},"isPrivate":false,"ignore":false,"code":"uniq: function (array) {\n    var out = []\n\n    if (!array) return out\n\n    for (var i=0; i < array.length; i++) {\n      var elem = array[i]\n      if (!~out.indexOf(elem)) out.push(elem)\n    };\n\n    return out\n  },"},{"tags":[{"type":"private"},{"type":"params"},{"type":"params"},{"type":"returns"}],"description":{"full":"<h2>Lunr.utils.intersect</h2>\n\n<p>Finds the intersect of the array with all other passed arrays.</p>","summary":"<h2>Lunr.utils.intersect</h2>\n\n<p>Finds the intersect of the array with all other passed arrays.</p>","body":""},"isPrivate":false,"ignore":false,"code":"intersect: function (array) {\n    var rest = Array.prototype.slice.call(arguments, 1),\n        uniquedArr = this.uniq(array),\n        len = uniquedArr.length,\n        out = []\n\n    for (var i=0; i < len; i++) {\n      var elem = uniquedArr[i],\n          inIntersect = true\n\n      for (var j=0; j < rest.length; j++) {\n        inIntersect = inIntersect && (~rest[j].indexOf(elem))\n      };\n\n      if (inIntersect) out.push(elem)\n    };\n\n    return out\n  },"},{"tags":[{"type":"private"},{"type":"params"},{"type":"returns"}],"description":{"full":"<h2>Lunr.utils.copy</h2>\n\n<p>Makes a copy of an object.</p>","summary":"<h2>Lunr.utils.copy</h2>\n\n<p>Makes a copy of an object.</p>","body":""},"isPrivate":false,"ignore":false,"code":"copy: function (obj) {\n    var out = {}\n    for (prop in obj) {\n      if (!obj.hasOwnProperty(prop)) return\n      out[prop] = obj[prop]\n    }\n    return out\n  },"},{"tags":[{"type":"private"},{"type":"params"},{"type":"params"},{"type":"params"}],"description":{"full":"<h2>Lunr.utils.forEachKey</h2>\n\n<p>Iterates through the passed object, yeilding each key to the passed function. Takes an<br />optional context object which will be used as the context in the passed function.</p>","summary":"<h2>Lunr.utils.forEachKey</h2>\n\n<p>Iterates through the passed object, yeilding each key to the passed function. Takes an<br />optional context object which will be used as the context in the passed function.</p>","body":""},"isPrivate":false,"ignore":false,"code":"forEachKey: function (obj, fn, ctx) {\n    for (prop in obj) {\n      fn.call(ctx, prop)\n    }\n  },"},{"tags":[{"type":"private"},{"type":"params"},{"type":"params"},{"type":"params"},{"type":"returns"}],"description":{"full":"<h2>Lunr.utils.mapKeys</h2>\n\n<p>Iterates through the passed object, yeilding each key to the passed function and returning<br />an array of the output of that function. Takes an optional context object which will be used<br />as the context in the passed function.</p>","summary":"<h2>Lunr.utils.mapKeys</h2>\n\n<p>Iterates through the passed object, yeilding each key to the passed function and returning<br />an array of the output of that function. Takes an optional context object which will be used<br />as the context in the passed function.</p>","body":""},"isPrivate":false,"ignore":false,"code":"mapKeys: function (obj, fn, ctx) {\n    var out = []\n    this.forEachKey(obj, function (key) {\n      out.push(fn.call(ctx, key))\n    })\n\n    return out\n  },"},{"tags":[{"type":"private"},{"type":"params"},{"type":"params"},{"type":"params"},{"type":"returns"}],"description":{"full":"<h2>Lunr.utils.map</h2>\n\n<p>A compatibility wrapper to allow the use of map in browsers which do not support<br />it natively.  If a native map is available this is used, otherwise a fallback is<br />used.</p>","summary":"<h2>Lunr.utils.map</h2>\n\n<p>A compatibility wrapper to allow the use of map in browsers which do not support<br />it natively.  If a native map is available this is used, otherwise a fallback is<br />used.</p>","body":""},"isPrivate":false,"ignore":false,"code":"map: function (arr, fn, ctx) {\n    var out = [],\n        len = arr.length\n\n    for (var i=0; i < len; i++) {\n      out.push(fn.call(ctx, arr[i], i, arr))\n    };\n\n    return out\n  },"},{"tags":[{"type":"private"},{"type":"params"},{"type":"params"},{"type":"params"},{"type":"returns"}],"description":{"full":"<h2>Lunr.utils.reduce</h2>\n\n<p>A compatibility wrapper to allow the use of reduce in browsers which do not support<br />it natively.  If a native reduce is available this is used, otherwise a fallback is<br />used.</p>","summary":"<h2>Lunr.utils.reduce</h2>\n\n<p>A compatibility wrapper to allow the use of reduce in browsers which do not support<br />it natively.  If a native reduce is available this is used, otherwise a fallback is<br />used.</p>","body":""},"isPrivate":false,"ignore":false,"code":"reduce: function (arr, fn, memo) {\n    var len = arr.length\n\n    for (var i=0; i < len; i++) {\n      memo = fn(memo, arr[i])\n    };\n\n    return memo\n  },"},{"tags":[{"type":"private"},{"type":"params"},{"type":"params"},{"type":"params"}],"description":{"full":"<h2>Lunr.utils.forEach</h2>\n\n<p>A compatibility wrapper to allow the use of forEach in browsers which do not support<br />it natively.  If a native forEach is available this is used, otherwise a fallback is<br />used.</p>","summary":"<h2>Lunr.utils.forEach</h2>\n\n<p>A compatibility wrapper to allow the use of forEach in browsers which do not support<br />it natively.  If a native forEach is available this is used, otherwise a fallback is<br />used.</p>","body":""},"isPrivate":false,"ignore":false,"code":"forEach: function (arr, fn, ctx) {\n    var len = arr.length\n    for (var i=0; i < len; i++) {\n      fn.call(ctx, arr[i], i, arr)\n    };\n  }\n};"},{"tags":[],"description":{"full":"<p>Lunr - Index<br />Copyright (C) 2011 Oliver Nightingale<br />MIT Licensed</p>","summary":"<p>Lunr - Index<br />Copyright (C) 2011 Oliver Nightingale<br />MIT Licensed</p>","body":""},"ignore":true,"code":"var Lunr.Index = (function () {"},{"tags":[{"type":"constructor"},{"type":"param","types":["String"],"name":"name","description":"- the name of this search index."}],"description":{"full":"<p>Lunr.Index provides the public api for the Lunr library.</p>","summary":"<p>Lunr.Index provides the public api for the Lunr library.</p>","body":""},"isPrivate":false,"ignore":false,"code":"var Index = function (name) {\n    this.name = name\n    this.refName = \"id\"\n    this.fields = {} // by default no fields will be indexed\n    this.trie = new Lunr.Trie ()\n  }","ctx":{"type":"function","name":"Index","string":"Index()"}},{"tags":[{"type":"param","types":["Object"],"name":"obj","description":"the object to add to the index."},{"type":"see","local":"Lunr.Document","visibility":"Lunr.Document"}],"description":{"full":"<p>Adds objects to the search index.</p>\n\n<p>It will convert the passed JSON object and convert it into a Lunr.Document.<br />The words from the document will then be extracted and added to the index.</p>","summary":"<p>Adds objects to the search index.</p>","body":"<p>It will convert the passed JSON object and convert it into a Lunr.Document.<br />The words from the document will then be extracted and added to the index.</p>"},"isPrivate":false,"ignore":false,"code":"Index.prototype.add = function (obj) {\n    var doc = new Lunr.Document(obj, this.refName, this.fields)\n    var words = doc.words()\n\n    for (var i=0; i < words.length; i++) {\n      var word = words[i]\n      this.trie.set(word.id, word.doc)\n    };\n  }","ctx":{"type":"method","constructor":"Index","name":"add","string":"Index.prototype.add()"}},{"tags":[{"type":"param","types":["String"],"name":"name","description":"the name of the field to index in a document"},{"type":"param","types":["Object"],"name":"opts","description":"options for indexing this particular field"},{"type":""},{"type":"Example:"},{"type":""},{"type":""},{"type":""}],"description":{"full":"<p>Adds fields to the index.</p>\n\n<p>Use this method to describe which fields from a document should be part of the index.<br />An options object can be passed as the second argument that will change the way that<br />a particular field is indexed.</p>\n\n<p><code>multiplier</code> is a multiplier to apply to a field, you can use this to make sure certain fields are<br />considered more important, e.g. a documents title.</p>","summary":"<p>Adds fields to the index.</p>","body":"<p>Use this method to describe which fields from a document should be part of the index.<br />An options object can be passed as the second argument that will change the way that<br />a particular field is indexed.</p>\n\n<p><code>multiplier</code> is a multiplier to apply to a field, you can use this to make sure certain fields are<br />considered more important, e.g. a documents title.</p>"},"isPrivate":false,"ignore":false,"code":"Index.prototype.field = function (name, opts) {\n    this.fields[name] = opts || {multiplier: 1}\n  }","ctx":{"type":"method","constructor":"Index","name":"field","string":"Index.prototype.field()"}},{"tags":[{"type":"param","types":["String"],"name":"name","description":"the name of the field to index in a document"},{"type":""},{"type":"Example:"},{"type":""},{"type":""}],"description":{"full":"<p>Sets the ref for the index.</p>\n\n<p>Use this method to select the property by which objects added to the index can be uniquely identified.</p>","summary":"<p>Sets the ref for the index.</p>","body":"<p>Use this method to select the property by which objects added to the index can be uniquely identified.</p>"},"isPrivate":false,"ignore":false,"code":"Index.prototype.ref = function (name) {\n    this.refName = name\n  }","ctx":{"type":"method","constructor":"Index","name":"ref","string":"Index.prototype.ref()"}},{"tags":[{"type":"param","types":["String"],"name":"term","description":"the term or terms to search the index for."},{"type":"returns"}],"description":{"full":"<p>Searches the index for a term.</p>\n\n<p>You can pass in a string of words separated by spaces.  By default the search is an AND search,<br />so if you searched for 'foo bar' the results would be those documents in the index that contain<br />both the word foo AND the word bar.</p>","summary":"<p>Searches the index for a term.</p>","body":"<p>You can pass in a string of words separated by spaces.  By default the search is an AND search,<br />so if you searched for 'foo bar' the results would be those documents in the index that contain<br />both the word foo AND the word bar.</p>"},"isPrivate":false,"ignore":false,"code":"Index.prototype.search = function (term) {\n    if (!term) return []\n\n    var docIds = Lunr.utils.map(Lunr.Word.fromString(term), function (word) {\n      var docs = this.trie\n        .get(word.toString())\n        .sort(function (a, b) {\n          if (a.exact && b.exact === undefined) return -1\n          if (b.exact && a.exact === undefined) return 1\n          if (a.score < b.score) return 1\n          if (a.score > b.score) return -1\n          return 0\n        })\n\n      return Lunr.utils.map(docs, function (doc) { return doc.documentId })\n    }, this)\n\n    return Lunr.utils.intersect.apply(Lunr.utils, docIds)\n  }","ctx":{"type":"method","constructor":"Index","name":"search","string":"Index.prototype.search()"}},{"tags":[],"description":{"full":"<p>Empties the index.</p>\n\n<p>It will delete the index store and create a new, empty one in its place.</p>","summary":"<p>Empties the index.</p>","body":"<p>It will delete the index store and create a new, empty one in its place.</p>"},"ignore":false,"code":"Index.prototype.empty = function () {\n    delete this.trie\n    this.trie = new Lunr.Trie\n  }","ctx":{"type":"method","constructor":"Index","name":"empty","string":"Index.prototype.empty()"}},{"tags":[{"type":"private"}],"description":{"full":"<p>exposing the constructor</p>","summary":"<p>exposing the constructor</p>","body":""},"isPrivate":false,"ignore":true,"code":"return Index\n})()"},{"tags":[],"description":{"full":"<p>Lunr - Document<br />Copyright (C) 2011 Oliver Nightingale<br />MIT Licensed</p>","summary":"<p>Lunr - Document<br />Copyright (C) 2011 Oliver Nightingale<br />MIT Licensed</p>","body":""},"ignore":true,"code":"Lunr.Document = (function () {","ctx":{"type":"property","receiver":"Lunr","name":"Document","value":"(function () {","string":"Lunr.Document"}},{"tags":[{"type":"constructor"},{"type":"param","types":["Object"],"name":"original","description":"- the document to be added to the search index."},{"type":"param","types":["String"],"name":"refName","description":"- the name of the property that can be used as a reference to this document in the index."},{"type":"param","types":["Object"],"name":"fields","description":"- the fields object from the index, indicationg which fields from the document need indexing."}],"description":{"full":"<p>Lunr.Document wraps any document that is added to the index.  It extracts any words from the document<br />fields that need indexing and formats the document in a way ready for insertion into the Lunr.Index<br />docStore.</p>","summary":"<p>Lunr.Document wraps any document that is added to the index.  It extracts any words from the document<br />fields that need indexing and formats the document in a way ready for insertion into the Lunr.Index<br />docStore.</p>","body":""},"isPrivate":false,"ignore":false,"code":"var Document = function (original, refName, fields) {\n    this.original = original\n    this.fields = fields\n    this.ref = original[refName]\n  }","ctx":{"type":"function","name":"Document","string":"Document()"}},{"tags":[{"type":"returns"}],"description":{"full":"<p>Returns a json representation of the document.</p>\n\n<p>Converts this instance of Lunr.Document into a plain object ready for insertion into the index.<br />The returned object consists of three properties, an id, an array of Lunr.Word ids and the<br />original document.</p>","summary":"<p>Returns a json representation of the document.</p>","body":"<p>Converts this instance of Lunr.Document into a plain object ready for insertion into the index.<br />The returned object consists of three properties, an id, an array of Lunr.Word ids and the<br />original document.</p>"},"isPrivate":false,"ignore":false,"code":"Document.prototype.asJSON = function () {\n    return {\n      id: this.ref,\n      words: Lunr.utils.map(this.words(), function (word) { return word.id }),\n      original: this.original\n    }\n  }","ctx":{"type":"method","constructor":"Document","name":"asJSON","string":"Document.prototype.asJSON()"}},{"tags":[{"type":"see","local":"Lunr.Word","visibility":"Lunr.Word"},{"type":"returns"}],"description":{"full":"<p>Retrurns a list of words within the document.</p>\n\n<p>For each field in the original document that requires indexing this method will create an instance of<br />Lunr.Word and then tally the total score for that word in the document as a whole.  At this time any<br />multiplier specified in the fields object will be applied.</p>\n\n<p>The list of words will then be converted into a format ready for insertion into the index.</p>","summary":"<p>Retrurns a list of words within the document.</p>","body":"<p>For each field in the original document that requires indexing this method will create an instance of<br />Lunr.Word and then tally the total score for that word in the document as a whole.  At this time any<br />multiplier specified in the fields object will be applied.</p>\n\n<p>The list of words will then be converted into a format ready for insertion into the index.</p>"},"isPrivate":false,"ignore":false,"code":"Document.prototype.words = function () {\n    var words = {}\n    var self = this\n    var allWords = {}\n\n    Lunr.utils.forEachKey(this.fields, function (fieldName) {\n      var wordObjs = Lunr.Word.fromString(self.original[fieldName]),\n          numberOfWords = wordObjs.length\n\n      for (var i=0; i < numberOfWords; i++) {\n        var word = wordObjs[i].toString()\n\n        if (!(word in allWords)) {\n          allWords[word] = { score: 0, ref: self.ref }\n        };\n\n        allWords[word].score = allWords[word].score + self.fields[fieldName].multiplier\n      };\n    })\n\n    return Lunr.utils.mapKeys(allWords, function (word) {\n      return {id: word, doc: {score: allWords[word].score, documentId: self.ref} }\n    })\n  }\n\n  return Document\n})()","ctx":{"type":"method","constructor":"Document","name":"words","string":"Document.prototype.words()"}},{"tags":[],"description":{"full":"<p>Lunr - Trie<br />Copyright (C) 2011 Oliver Nightingale<br />MIT Licensed</p>","summary":"<p>Lunr - Trie<br />Copyright (C) 2011 Oliver Nightingale<br />MIT Licensed</p>","body":""},"ignore":true,"code":"Lunr.Trie = (function () {","ctx":{"type":"property","receiver":"Lunr","name":"Trie","value":"(function () {","string":"Lunr.Trie"}},{"tags":[{"type":"constructor"},{"type":"private"}],"description":{"full":"<p>A node in the trie</p>","summary":"<p>A node in the trie</p>","body":""},"isPrivate":false,"ignore":false,"code":"var Node = function () {\n    this.children = {}\n    this.values = []\n  }","ctx":{"type":"function","name":"Node","string":"Node()"}},{"tags":[{"type":"private"},{"type":"params"},{"type":"returns"}],"description":{"full":"<p>Returns the correct child node for the given key.</p>","summary":"<p>Returns the correct child node for the given key.</p>","body":""},"isPrivate":false,"ignore":false,"code":"Node.prototype.childForKey = function (key) {\n\n    var child = this.children[key]\n\n    if (!child) {\n      child = new Node ()\n      this.children[key] = child\n    };\n\n    return child\n  }","ctx":{"type":"method","constructor":"Node","name":"childForKey","string":"Node.prototype.childForKey()"}},{"tags":[{"type":"constructor"}],"description":{"full":"<p>Lunr.Trie stores the built search index.  It handles lookups against the index and the building of the index.</p>","summary":"<p>Lunr.Trie stores the built search index.  It handles lookups against the index and the building of the index.</p>","body":""},"isPrivate":false,"ignore":false,"code":"var Trie = function () {\n    this.root = new Node ()\n  }","ctx":{"type":"function","name":"Trie","string":"Trie()"}},{"tags":[{"type":"param","types":["String"],"name":"key","description":"the key will be used to lookup values"},{"type":"returns"}],"description":{"full":"<p>Gets objects from the trie which match the passed key.</p>\n\n<p>Takes a key and gets all objects from the trie which could match the key.</p>","summary":"<p>Gets objects from the trie which match the passed key.</p>","body":"<p>Takes a key and gets all objects from the trie which could match the key.</p>"},"isPrivate":false,"ignore":false,"code":"Trie.prototype.get = function (key) {\n    var keys = this.keys(key)\n    var self = this\n\n    return Lunr.utils.reduce(keys, function (res, k) {\n      Lunr.utils.forEach(self.getNode(k).values, function (v) {\n        var val = Lunr.utils.copy(v)\n        if (key === k) val.exact = true\n        res.push(val)\n      })\n      return res\n    }, [])\n  }","ctx":{"type":"method","constructor":"Trie","name":"get","string":"Trie.prototype.get()"}},{"tags":[{"type":"param","types":["String"],"name":"key","description":"the key will be used to lookup values"},{"type":"returns"}],"description":{"full":"<p>Gets nodes from the trie for the given key.</p>\n\n<p>Takes a key and gets the node for that key.</p>","summary":"<p>Gets nodes from the trie for the given key.</p>","body":"<p>Takes a key and gets the node for that key.</p>"},"isPrivate":false,"ignore":false,"code":"Trie.prototype.getNode = function (key) {\n    var recursiveGet = function (node, key) {\n      if (!key.length) return node\n      return recursiveGet(node.childForKey(key.charAt(0)), key.slice(1))\n    }\n\n    return recursiveGet(this.root, key)\n  }","ctx":{"type":"method","constructor":"Trie","name":"getNode","string":"Trie.prototype.getNode()"}},{"tags":[{"type":"param","types":["String"],"name":"term","description":"the prefix to search with"},{"type":"returns"}],"description":{"full":"<p>Gets all keys from the trie that have a given prefix.</p>\n\n<p>Takes the given prefix and walks the trie, returning all keys which contain the prefix.</p>","summary":"<p>Gets all keys from the trie that have a given prefix.</p>","body":"<p>Takes the given prefix and walks the trie, returning all keys which contain the prefix.</p>"},"isPrivate":false,"ignore":false,"code":"Trie.prototype.keys = function (term) {\n    var keys = [],\n        term = term || \"\"\n\n    var getKeys = function (node, term) {\n      if (node.values.length) keys.push(term)\n\n      Lunr.utils.forEachKey(node.children, function (childKey) {\n        getKeys(node.children[childKey], term + childKey)\n      })\n    }\n\n    getKeys(this.getNode(term), term)\n    return keys\n  }","ctx":{"type":"method","constructor":"Trie","name":"keys","string":"Trie.prototype.keys()"}},{"tags":[{"type":"param","types":["String"],"name":"key","description":"the key under which the value should be stored"},{"type":"param","types":["Object"],"name":"value","description":"the value to store"}],"description":{"full":"<p>Set a key to the passed value.</p>\n\n<p>Takes a key and a value, walks through the trie to the right node and adds the<br />given value to that node.</p>","summary":"<p>Set a key to the passed value.</p>","body":"<p>Takes a key and a value, walks through the trie to the right node and adds the<br />given value to that node.</p>"},"isPrivate":false,"ignore":false,"code":"Trie.prototype.set = function (key, value) {\n    var recursiveSet = function (node, key) {\n      if (!key.length) return node.values.push(value)\n      recursiveSet(node.childForKey(key.charAt(0)), key.slice(1))\n    }\n\n    return recursiveSet(this.root, key)\n  }\n\n  return Trie\n})();","ctx":{"type":"method","constructor":"Trie","name":"set","string":"Trie.prototype.set()"}},{"tags":[],"description":{"full":"<p>Lunr - Word<br />Copyright (C) 2011 Oliver Nightingale<br />MIT Licensed</p>","summary":"<p>Lunr - Word<br />Copyright (C) 2011 Oliver Nightingale<br />MIT Licensed</p>","body":""},"ignore":true,"code":"Lunr.Word = (function () {\n\n  var stopWords = [\"the\", \"of\", \"to\", \"and\", \"a\", \"in\", \"is\", \"it\", \"you\", \"that\", \"this\"]","ctx":{"type":"property","receiver":"Lunr","name":"Word","value":"(function () {","string":"Lunr.Word"}},{"tags":[{"type":"constructor"},{"type":"param","types":["String"],"name":"raw","description":"- the raw word to be used as the base of a search word."}],"description":{"full":"<p>A Lunr.Word wraps a string and provides methods to convert the string into a form ready for insertion<br />into the index.  It handles exclusion of stop word as well as performing any language based algorithms.</p>","summary":"<p>A Lunr.Word wraps a string and provides methods to convert the string into a form ready for insertion<br />into the index.  It handles exclusion of stop word as well as performing any language based algorithms.</p>","body":""},"isPrivate":false,"ignore":false,"code":"var Word = function (raw) {\n    this.raw = raw\n    this.out = this.raw.replace(/^\\W+/, \"\").replace(/\\W+$/, \"\").toLowerCase()\n  }\n\n  Word.fromString = function (str, splitter) {\n    var splitter = splitter || /\\b/g,\n        splitStr = str.split(splitter),\n        splitStrLen = splitStr.length,\n        out = []\n\n    for (var i=0; i < splitStrLen; i++) {\n      var word = new Lunr.Word (splitStr[i])\n      if (!word.isStopWord()) out.push(word)\n    };\n\n    return out\n  }","ctx":{"type":"function","name":"Word","string":"Word()"}},{"tags":[{"type":"returns"}],"description":{"full":"<p>Determines whether or not this word is a stop word.</p>","summary":"<p>Determines whether or not this word is a stop word.</p>","body":""},"isPrivate":false,"ignore":false,"code":"Word.prototype.isStopWord = function () {\n    return (stopWords.indexOf(this.raw.toLowerCase()) !== -1)\n  }","ctx":{"type":"method","constructor":"Word","name":"isStopWord","string":"Word.prototype.isStopWord()"}},{"tags":[{"type":"returns"}],"description":{"full":"<p>Converts the search word into a string representation.</p>","summary":"<p>Converts the search word into a string representation.</p>","body":""},"isPrivate":false,"ignore":false,"code":"Word.prototype.toString = function () {\n    if (this.isStopWord()) return\n    this.stem()\n    return this.out\n  }","ctx":{"type":"method","constructor":"Word","name":"toString","string":"Word.prototype.toString()"}},{"tags":[{"type":"author"},{"type":""},{"type":"June"},{"type":"Additions"}],"description":{"full":"<p>Stems the current word.</p>\n\n<p>Stemming is the process for reducing inflected (or sometimes derived) words to their stem, base or root<br />form. Porter stemming is designed for the English language.</p>\n\n<p>This code has been slighly adapted from Martin Porter's examples.<br /> - <a href='http://tartarus.org/~martin/PorterStemmer/'>http://tartarus.org/~martin/PorterStemmer/</a></p>\n\n<p>Please assume any errors found in the below code are translation errors<br />inserted by myself and not those of the original authors.</p>","summary":"<p>Stems the current word.</p>","body":"<p>Stemming is the process for reducing inflected (or sometimes derived) words to their stem, base or root<br />form. Porter stemming is designed for the English language.</p>\n\n<p>This code has been slighly adapted from Martin Porter's examples.<br /> - <a href='http://tartarus.org/~martin/PorterStemmer/'>http://tartarus.org/~martin/PorterStemmer/</a></p>\n\n<p>Please assume any errors found in the below code are translation errors<br />inserted by myself and not those of the original authors.</p>"},"isPrivate":false,"ignore":false,"code":"Word.prototype.stem = (function () {\n    var step2list = {\n      \"ational\" : \"ate\",\n      \"tional\"  : \"tion\",\n      \"enci\"    : \"ence\",\n      \"anci\"    : \"ance\",\n      \"izer\"    : \"ize\",\n      \"bli\"     : \"ble\",\n      \"alli\"    : \"al\",\n      \"entli\"   : \"ent\",\n      \"eli\"     : \"e\",\n      \"ousli\"   : \"ous\",\n      \"ization\" : \"ize\",\n      \"ation\"   : \"ate\",\n      \"ator\"    : \"ate\",\n      \"alism\"   : \"al\",\n      \"iveness\" : \"ive\",\n      \"fulness\" : \"ful\",\n      \"ousness\" : \"ous\",\n      \"aliti\"   : \"al\",\n      \"iviti\"   : \"ive\",\n      \"biliti\"  : \"ble\",\n      \"logi\"    : \"log\"\n    }\n\n    var step3list = {\n      \"icate\" : \"ic\",\n      \"ative\" : \"\",\n      \"alize\" : \"al\",\n      \"iciti\" : \"ic\",\n      \"ical\"  : \"ic\",\n      \"ful\"   : \"\",\n      \"ness\"  : \"\"\n    }\n\n    var c = \"[^aeiou]\";          // consonant\n    var v = \"[aeiouy]\";          // vowel\n    var C = c + \"[^aeiouy]*\";    // consonant sequence\n    var V = v + \"[aeiou]*\";      // vowel sequence\n\n    var mgr0 = \"^(\" + C + \")?\" + V + C;               // [C]VC... is m>0\n    var meq1 = \"^(\" + C + \")?\" + V + C + \"(\" + V + \")?$\";  // [C]VC[V] is m=1\n    var mgr1 = \"^(\" + C + \")?\" + V + C + V + C;       // [C]VCVC... is m>1\n    var s_v   = \"^(\" + C + \")?\" + v;                   // vowel in stem\n\n    return function () {\n      var stem;\n      var suffix;\n      var firstch;\n      var origword = this.out;\n      var w = this.out;\n\n      if (origword.length < 3) return origword\n\n      var re;\n      var re2;\n      var re3;\n      var re4;\n\n      firstch = origword.substr(0,1);\n      if (firstch == \"y\") {\n        w = firstch.toUpperCase() + w.substr(1);\n      }\n\n      // Step 1a\n      re = /^(.+?)(ss|i)es$/;\n      re2 = /^(.+?)([^s])s$/;\n\n      if (re.test(w)) { \n        w = w.replace(re,\"$1$2\");\n      } else if (re2.test(w)) { \n        w = w.replace(re2,\"$1$2\");\n      }\n\n      // Step 1b\n      re = /^(.+?)eed$/;\n      re2 = /^(.+?)(ed|ing)$/;\n      if (re.test(w)) {\n        var fp = re.exec(w);\n        re = new RegExp(mgr0);\n        if (re.test(fp[1])) {\n          re = /.$/;\n          w = w.replace(re,\"\");\n        }\n      } else if (re2.test(w)) {\n        var fp = re2.exec(w);\n        stem = fp[1];\n        re2 = new RegExp(s_v);\n        if (re2.test(stem)) {\n          w = stem;\n          re2 = /(at|bl|iz)$/;\n          re3 = new RegExp(\"([^aeiouylsz])\\\\1$\");\n          re4 = new RegExp(\"^\" + C + v + \"[^aeiouwxy]$\");\n          if (re2.test(w)) {  w = w + \"e\"; }\n          else if (re3.test(w)) { re = /.$/; w = w.replace(re,\"\"); }\n          else if (re4.test(w)) { w = w + \"e\"; }\n        }\n      }\n\n      // Step 1c\n      re = /^(.+?)y$/;\n      if (re.test(w)) {\n        var fp = re.exec(w);\n        stem = fp[1];\n        re = new RegExp(s_v);\n        if (re.test(stem)) { w = stem + \"i\"; }\n      }\n\n      // Step 2\n      re = /^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/;\n      if (re.test(w)) {\n        var fp = re.exec(w);\n        stem = fp[1];\n        suffix = fp[2];\n        re = new RegExp(mgr0);\n        if (re.test(stem)) {\n          w = stem + step2list[suffix];\n        }\n      }\n\n      // Step 3\n      re = /^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/;\n      if (re.test(w)) {\n        var fp = re.exec(w);\n        stem = fp[1];\n        suffix = fp[2];\n        re = new RegExp(mgr0);\n        if (re.test(stem)) {\n          w = stem + step3list[suffix];\n        }\n      }\n\n      // Step 4\n      re = /^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/;\n      re2 = /^(.+?)(s|t)(ion)$/;\n      if (re.test(w)) {\n        var fp = re.exec(w);\n        stem = fp[1];\n        re = new RegExp(mgr1);\n        if (re.test(stem)) {\n          w = stem;\n        }\n      } else if (re2.test(w)) {\n        var fp = re2.exec(w);\n        stem = fp[1] + fp[2];\n        re2 = new RegExp(mgr1);\n        if (re2.test(stem)) {\n          w = stem;\n        }\n      }\n\n      // Step 5\n      re = /^(.+?)e$/;\n      if (re.test(w)) {\n        var fp = re.exec(w);\n        stem = fp[1];\n        re = new RegExp(mgr1);\n        re2 = new RegExp(meq1);\n        re3 = new RegExp(\"^\" + C + v + \"[^aeiouwxy]$\");\n        if (re.test(stem) || (re2.test(stem) && !(re3.test(stem)))) {\n          w = stem;\n        }\n      }\n\n      re = /ll$/;\n      re2 = new RegExp(mgr1);\n      if (re.test(w) && re2.test(w)) {\n        re = /.$/;\n        w = w.replace(re,\"\");\n      }\n\n      if (firstch == \"y\") {\n        w = firstch.toLowerCase() + w.substr(1);\n      }\n\n      this.out = w;\n    }\n\n  })()\n\n  return Word\n})","ctx":{"type":"property","constructor":"Word","name":"stem","value":"(function () {","string":"Word.prototypestem"}}]